# 代理模式

代理模式，可以分为两种，一种是静态代理，一种是动态代理。

两种代理从虚拟机加载类的角度来讲，本质上都是一样的，都是在原有类的行为基础上，加入一些多出的行为，甚至完全替换原有的行为。

静态代理采用的方式就是我们手动的将这些行为换进去，然后让编译器帮我们编译，同时也就将字节码在原有类的基础上加入一些其他的东西或者替换原有的东西，产生一个新的与原有类接口相同却行为不同的类型。

1 代理模式定义
定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。

本篇文章主要介绍的是静态代理，关于动态代理请参考：设计模式之动态代理(dynamic proxy)

2 代理模式的作用
在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
通过代理类对原有类进行功能增强，如增加缓存、异常处理、日志处理等，Spring AOP用的就是（动态）代理模式
3 代理模式一般涉及到的角色有：
抽象主题(Subject)：声明真实对象和代理对象的共同接口；
代理(Proxy)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。
真实对象(RealSubject)：代理角色所代表的真实对象，是我们最终要引用的对象。

静态代理缺点：
如果需要代理的类只有一个，那么静态代理没什么问题，如果有很多类需要代理呢，用静态代理的话就需要为每一个类创建一个代理类，显然这么做太过繁琐也容易出错。

2 动态代理的作用
数据库连接以及事物管理
单元测试中的动态 Mock 对象
自定义工厂与依赖注入（DI）容器之间的适配器
类似 AOP 的方法拦截器
日志、缓存等业务增强
Java RMI远程通信
各种访问控制器、验证器
… …
3 动态代理的原理
动态代理主要是利用了Java的反射机制。

4 动态代理类的创建

要创建一个动态代理，只需要利用Java API提供的两个类：

java.lang.reflect.InvocationHandler： 这是调用处理器接口，它自定义了一个 invoke() 方法，我们就在这个方法里触发代理对象自己的方法，你可以在它的前后增加我们自己的增强方法。

java.lang.reflect.Proxy： 这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象，也就是动态生成代理对象的方法。

每个代理类的对象都会关联一个表示内部处理逻辑的InvocationHandler接口的实现。当使用者调用了代理对象所代理的接口中的方法的时候，这个调用的信息会被传递给InvocationHandler的invoke()方法。在 invoke()方法的参数中可以获取到代理对象、方法对应的Method对象和调用的实际参数。invoke()方法的返回值被返回给使用者。这种做法实际上相 当于对方法调用进行了拦截。熟悉AOP的人对这种使用模式应该不陌生。但是这种方式不需要依赖AspectJ等AOP框架。

ClassLoader loader表示当前使用到的appClassloader。

Class<?>[] interfaces表示目标对象实现的一组接口。

InvocationHandler h表示当前的InvocationHandler实现实例对象。
